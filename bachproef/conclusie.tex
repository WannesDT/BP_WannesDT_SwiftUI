%%=============================================================================
%% Conclusie
%%=============================================================================

\chapter{Conclusie}%
\label{ch:conclusie}

% TODO: Trek een duidelijke conclusie, in de vorm van een antwoord op de
% onderzoeksvra(a)g(en). Wat was jouw bijdrage aan het onderzoeksdomein en
% hoe biedt dit meerwaarde aan het vakgebied/doelgroep? 
% Reflecteer kritisch over het resultaat. In Engelse teksten wordt deze sectie
% ``Discussion'' genoemd. Had je deze uitkomst verwacht? Zijn er zaken die nog
% niet duidelijk zijn?
% Heeft het onderzoek geleid tot nieuwe vragen die uitnodigen tot verder 
%onderzoek?


\newpage
In dit hoofdstuk word er een antwoord gegeven op de onderzoeksvragen die eerder in deze proef vermeld werden. Hier worden de resultaten samen gebracht tot een conclusie waaruit app-ontwikkelaars informatie kunnen halen om zo doordachte keuzes te kunnen maken voor het ontwikkelen van SwiftUI-Applicaties.
 
\section{Nieuwe Observable macro}
Op basis van de besproken gegevens met betrekking tot Observable in vergelijking met de andere methoden voor data-binding in SwiftUI, kunnen de volgende conclusies worden getrokken:
\subsection{refresh times}
Observable biedt een van de snelste refresh times (2.52 microseconden) onder de onderzochte methoden. Dit betekent dat het updaten van de UI met Observable efficiënt en snel verloopt, wat resulteert in een responsieve gebruikerservaring.
\subsection{CPU-verbruik}
Observable heeft echter een hoger CPU-verbruik (19.45 megacycli) in vergelijking met andere methoden, zoals Binding (14.08 megacycli). Dit kan een nadeel zijn als je probeert CPU-gebruik te minimaliseren.
\subsection{Property Updates}
Observable voert slechts één update per aanpassing uit, wat leidt tot een lagere updatefrequentie vergeleken met Binding, ObservedObject en EnvironmentObject, die tweemaal updaten per aanpassing. Dit kan in sommige gevallen resulteren in langzamere reacties op veranderingen.
\subsection{Gebruikssituaties}
Door de efficiënte refresh times en lagere updatefrequentie kan Observable een goede keuze zijn voor applicaties waar snelheid belangrijk is en waar updates minder frequent zijn. In situaties waarin nauwkeurige en consistente state-updates van cruciaal belang zijn, kunnen echter andere methoden, zoals Binding, ObservedObject, of EnvironmentObject, geschikter zijn.
 
\newpage
\section{Aanbevelingen}
Door rekening te houden met deze conclusies en aanbevelingen, kunt u de juiste keuzes maken bij het ontwerpen van SwiftUI-applicaties, en zo een goede balans vinden tussen efficiëntie, snelheid en consistentie.
\subsection{Kies de juiste methode voor specifieke behoeften}
Gebruik Observable en EnvironmentObject wanneer snelheid en efficiëntie in het updaten van de UI prioriteit hebben.
Environment biedt een gebalanceerde aanpak voor het delen van data over verschillende componenten heen.
\subsection{overhead}
Binding en ObservedObject kunnen meer overhead en trager CPU-verbruik veroorzaken. Gebruik ze met voorzichtigheid, vooral als prestaties belangrijk zijn.
\subsection{frequentie van updates}
Kies een benadering die past bij de frequentie van updates in uw applicatie. Meer updates zorgen voor een snellere state, maar kunnen ook de CPU-belasting verhogen.




