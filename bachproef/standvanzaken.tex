\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

\section{Swift}

\section{SwiftUI}
\subsection{Views}

\section{XCTest}

\section{Annotations}
\subsection{@propertyWrapper}
\autocite{ApplePropertyWrapper} Een property wrapper voegt een scheidingslaag toe tussen de code die beheert hoe een property word opgeslagen en de code die een eigenschap definieert. Dit is interessant om te begrijpen omdat alle volgende annotaties property wrappers zijn.
\begin{swift}[caption=Example property wrapper code, label=property_wrapper_example]
    @propertyWrapper
    struct TwelveOrLess {
        private var number = 0
        var wrappedValue: Int {
            get { return number }
            set { number = min(newValue, 12) }
        }
    }
    
    struct SmallRectangle {
        @TwelveOrLess var height: Int
        @TwelveOrLess var width: Int
    }
    
    
    var rectangle = SmallRectangle()
    print(rectangle.height)
    // Prints "0"
    
    
    rectangle.height = 10
    print(rectangle.height)
    // Prints "10"
    
    
    rectangle.height = 24
    print(rectangle.height)
    // Prints "12"
\end{swift}


\subsection{@State}
\autocite{AppleState} State is een propertywrapper dat een waarde kan lezen en schrijven die word beheerd door SwiftUI. State word gebruikt voor de enige bron van de ``truth''(waarheid) voor een gegeven value type dat opgeslagen wordt binnen de view hierarchy.

\begin{swift}[caption=Example of @State code, label=state_example]
    struct PlayButton: View {
        @State private var isPlaying: Bool = false // Create the state.
        
        
        var body: some View {
            Button(isPlaying ? "Pause" : "Play") { // Read the state.
                isPlaying.toggle() // Write the state.
            }
        }
    }
\end{swift}


\subsection{@Binding}
\autocite{AppleBinding} Binding word gebruikt om een 2-way connection te leggen tussen een property dat data opslaat en een view dat data weergeeft. Een binding verbind een property met een bron van ``truth''(waarheid) in plaats van zelf de data op te slaan.

\begin{swift}[caption=Example of @Binding code, label=binding_example]
    struct PlayButton: View {
        @Binding var isPlaying: Bool
        
        
        var body: some View {
            Button(isPlaying ? "Pause" : "Play") {
                isPlaying.toggle()
            }
        }
    }
    
    struct PlayerView: View {
        var episode: Episode
        @State private var isPlaying: Bool = false
        
        
        var body: some View {
            VStack {
                Text(episode.title)
                .foregroundStyle(isPlaying ? .primary : .secondary)
                PlayButton(isPlaying: $isPlaying) // Pass a binding.
            }
        }
    }
\end{swift}


\subsection{@ObservableObject}
\autocite{AppleObservableObject} Een ObservableObject is een object dat veranderingen in zijn staat kan detecteren en hier melding(objectWillChange) van kan maken aan geïnteresseerde partijen, meestal via het Observer-patroon. Dit is een belangrijk concept in het kader van het ontwikkelen van applicaties met een reactieve programmeerstijl.

\subsubsection{Observer Pattern}
\autocite{MediumDesignPatterns} Dit patroon is een gedragspatroon waarbij een object, dat de 'observable' of 'subject' wordt genoemd, een lijst met afhankelijkheden bijhoudt, ook wel 'observers' genoemd. Wanneer het observable object verandert, worden alle geïnteresseerde observers op de hoogte gesteld van deze verandering.

\subsubsection{@Published}
\autocite{ApplePublished} De eenvoudigste manier om een object als observable te maken, is door de @Published-property wrapper te gebruiken voor eigenschappen die je wilt observeren. Wanneer de waarde van een eigenschap die is gemarkeerd met @Published verandert, zal het observable object automatisch melding maken van deze verandering aan alle geabonneerde observers.

\begin{swift}[caption=Example of implemented Observable Pattern, label=observable_example]
class Contact: ObservableObject {
    @Published var name: String
    @Published var age: Int
    
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    
    
    func haveBirthday() -> Int {
        age += 1
        return age
    }
}


let john = Contact(name: "John Appleseed", age: 24)
cancellable = john.objectWillChange
.sink { _ in
    print("(john.age) will change")
}
print(john.haveBirthday())
// Prints "24 will change"
// Prints "25"
\end{swift}

\subsection{@StateObject}
StateObject is een property wrapper in SwiftUI, waarmee je een instantie van een observable object kunt maken en behouden gedurende de levensduur van een specifieke SwiftUI View. Dit is handig wanneer je een observable object wilt gebruiken om de staat van een weergave te beheren, maar je wilt niet dat deze wordt gedeeld tussen verschillende instanties van dezelfde weergave.

\begin{swift}[caption=Example of StateObject, label=stateobject_example]
class MyData: ObservableObject {
    @Published var value: Int = 0
}

struct ContentView: View {
    @StateObject var data = MyData()
    
    var body: some View {
        VStack {
            ChildView(data: data)
            AnotherChildView(data: data)
        }
    }
}

struct ChildView: View {
    @ObservedObject var data: MyData
    
    var body: some View {
        VStack {
            Text("Value in ChildView: (data.value)")
            Button("Increment in ChildView") {
                data.value += 1
            }
        }
    }
}
struct AnotherChildView: View {
    @ObservedObject var data: MyData
    
    var body: some View {
        VStack {
            Text("Value in AnotherChildView: (data.value)")
            Button("Increment in AnotherChildView") {
                data.value += 1
            }
        }
    }
}

\end{swift}

\subsection{@Observable}
\autocite{AppleObservable} @Observable is een macro die gebruikt wordt in SwiftUI om het observer-patroon te implementeren. Dit patroon stelt een object in staat om een lijst van observers bij te houden en hen te notificeren over specifieke of algemene staatveranderingen. Deze macro is beschikbaar vanaf ios 17.0 en later. Deze macro is gemaakt om alle voorgaande macro's te vervangen.

\begin{swift}[caption=Example of Observable, label=Observable_example]
// ViewModel met @Observable macro
@Observable class SimpleViewModel {
    var text = "Hello World :)"
}

// SwiftUI View
struct SimpleView: View {
    @Environment(SimpleViewModel.self) var viewModel
    
    var body: some View {
        Text(viewModel.text)
    }
}
\end{swift}


\subsection{@Environment}
\autocite{AppleEnvironment} In SwiftUI biedt @Environment een mechanisme om waarden door te geven door de view-hiërarchie, zonder ze expliciet door te geven aan elke view als afzonderlijke eigenschappen. Het maakt gebruik van de omgeving van de View om gegevens te delen tussen Views in een hiërarchie. Dit is handig voor het doorgeven van gegevens die van toepassing zijn op de hele app of een deel ervan, zoals thema's, kleuren, taalinstellingen, enzovoort.


\begin{swift}[caption=Example of Observable, label=Observable_example]
struct ContentView: View {
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        VStack {
            Text("Current color scheme is (colorScheme)")
            ChildView()
        }
    }
}

struct ChildView: View {
    var body: some View {
        Text("This is a child view")
    }
}
\end{swift}

